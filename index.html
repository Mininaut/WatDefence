<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watermelon Defense Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #2c3e50 0%, #1a1a2e 100%);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            color: #ecf0f1;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        
        canvas {
            background: #1a1a2e;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            border: none;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ecf0f1;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            user-select: none;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #shop {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            width: 200px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .shopItem {
            margin-bottom: 15px;
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .shopItem:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .shopItemTitle {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 12px;
            color: #bdc3c7;
        }
        
        button {
            background: rgba(46, 204, 113, 0.2);
            color: #ecf0f1;
            border: 1px solid rgba(46, 204, 113, 0.3);
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(46, 204, 113, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(2px);
        }
        
        button:disabled {
            background: rgba(127, 140, 141, 0.2);
            border: 1px solid rgba(127, 140, 141, 0.3);
            cursor: not-allowed;
        }
        
        #inventory {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .inventoryItem {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .inventoryItem:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .inventoryItem.selected {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        
        .inventoryCount {
            position: absolute;
            bottom: 2px;
            right: 5px;
            font-size: 10px;
            color: #bdc3c7;
        }
        
        #achievements {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            max-width: 200px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        #achievements:hover {
            opacity: 1;
        }
        
        .achievement {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .achievement.unlocked {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        
        #levelDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .levelBar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .levelProgress {
            height: 100%;
            background: rgba(46, 204, 113, 0.5);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Pause menu styles */
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.6);
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            display: none;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #pauseButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 10;
            font-size: 12px;
            backdrop-filter: blur(5px);
        }
        
        /* Game elements styles */
        .watermelon {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .turret {
            position: absolute;
            transform-origin: center;
            transition: transform 0.3s ease;
        }
        
        .barricade {
            position: absolute;
            transform-origin: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .laser-beam {
            position: absolute;
            height: 2px;
            background: rgba(52, 152, 219, 0.5);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
            transform-origin: left center;
        }
        
        .force-field {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(241, 196, 15, 0.3);
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.2);
        }
        
        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(231, 76, 60, 0.5) 0%, rgba(230, 126, 34, 0.3) 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: explode 0.5s ease-out;
        }
        
        @keyframes explode {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <p>Press ESC or click Resume to continue</p>
            <button id="resumeButton">Resume</button>
        </div>
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="ui">
            Money: $<span id="moneyDisplay">0</span><br>
            Score: <span id="scoreDisplay">0</span>
        </div>
        <div id="levelDisplay">
            Level: <span id="level">1</span>
            <div class="levelBar">
                <div class="levelProgress" id="levelProgress"></div>
            </div>
        </div>
        <div id="achievements">
            <h4 style="margin-top:0;text-align:center;">Achievements</h4>
            <div class="achievement" id="achFirstKill">First Kill</div>
            <div class="achievement" id="achTurretMaster">Turret Master</div>
            <div class="achievement" id="achBarricadeKing">Barricade King</div>
            <div class="achievement" id="achRich">Rich!</div>
        </div>
        <div id="shop">
            <h3 style="text-align:center;margin-top:0;width:100%;">SHOP</h3>
            <div class="shopItem" id="hammerUpgradeItem">
                <div class="shopItemTitle">Hammer Upgrade ($50)</div>
                <button id="hammerUpgrade">Buy</button>
            </div>
            <div class="shopItem" id="autohammerItem">
                <div class="shopItemTitle">Autohammer ($200)</div>
                <button id="buyAutoHammer">Buy</button>
            </div>
            <div class="shopItem" id="turretItem">
                <div class="shopItemTitle">Turret ($300)</div>
                <button id="buyTurret">Buy</button>
            </div>
            <div class="shopItem" id="barricadeItem">
                <div class="shopItemTitle">Barricade ($150)</div>
                <button id="buyBarricade">Buy</button>
            </div>
            <div class="shopItem" id="repairItem">
                <div class="shopItemTitle">Repair Pineapple ($100)</div>
                <button id="repairPineapple">Buy</button>
            </div>
        </div>
        <div id="inventory">
            <div class="inventoryItem" id="hammerItem" data-type="hammer">
                üî®
                <span class="inventoryCount" id="hammerLevel">1</span>
            </div>
            <div class="inventoryItem" id="autohammerItem" data-type="autohammer">
                ‚öíÔ∏è
                <span class="inventoryCount" id="autohammerCount">0</span>
            </div>
            <div class="inventoryItem" id="turretItem" data-type="turret">
                üî´
                <span class="inventoryCount" id="turretCount">0</span>
            </div>
            <div class="inventoryItem" id="barricadeItem" data-type="barricade">
                üöß
                <span class="inventoryCount" id="barricadeCount">0</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const moneyDisplay = document.getElementById('moneyDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        let money = 0;
        let score = 0;
        let watermelons = [];
        let autoHammers = [];  
        let turrets = [];      
        let barricades = [];
        let hammerLevel = 1;
        let hammerPos = { x: 0, y: 0 };
        let hammerSwinging = false;
        let hammerRotation = 0;
        let selectedItem = null;
        let autoHammerCount = 0;  
        let turretCount = 0;      
        let barricadeCount = 0;
        let combo = 0;
        let comboMultiplier = 1;
        let lastKillTime = 0;
        let comboTimeout = 3000; 
        let specialEffects = [];
        
        const WATERMELON_SIZE = 20;
        const LINE_X = canvas.width - 100;
        const BASE_HAMMER_DAMAGE = 2; 
        const SPLASH_RADIUS = 80; 
        
        let pineapple = {
            x: canvas.width - 50,
            y: canvas.height / 2,
            health: 100,
            maxHealth: 100
        };
        
        let gameState = {
            money: 0,
            score: 0,
            hammerLevel: 1,
            level: 1,
            autoHammerCount: 0,  
            turretCount: 0,          
            barricadeCount: 0,
            experience: 0,
            experienceToNextLevel: 100,
            achievements: {
                firstKill: false,
                turretMaster: false,
                barricadeKing: false,
                rich: false
            }
        };
        
        const hammerSvg = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <path d="M42.696,4.475v-2.85c0-0.894,0.73-1.625,1.623-1.625h11.357c0.894,0,1.625,0.731,1.625,1.625v2.85H42.696z"/>
                <path d="M42.696,42.366v53.159h-0.002v2.851c0,0.893,0.731,1.624,1.624,1.624h11.357c0.894,0,1.624-0.731,1.624-1.624v-2.851h0.002V42.366H42.696z"/>
                <path d="M73.476,8.068c-0.406-0.405-1.209-0.738-1.783-0.738H51.044c-0.574,0-1.514,0-2.088,0H28.308c-0.574,0-1.377,0.333-1.783,0.738l-2.704,2.705c-0.406,0.405-0.738,1.208-0.738,1.782v21.727c0,0.574,0.332,1.377,0.738,1.782l2.704,2.705c0.406,0.405,1.209,0.738,1.783,0.738h20.649c0.574,0,1.514,0,2.088,0h20.648c0.574,0,1.377-0.333,1.783-0.738l2.704-2.705c0.406-0.405,0.738-1.208,0.738-1.782V12.556c0-0.574-0.332-1.377-0.738-1.782L73.476,8.068z"/>
            </svg>
        `;
        
        const hammerImg = new Image();
        hammerImg.src = 'data:image/svg+xml;base64,' + btoa(hammerSvg);
        
        const turretImg = new Image();
        turretImg.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
            <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="25" width="30" height="15" stroke="black" stroke-width="2" fill="white"/>
                <line x1="14" y1="40" x2="12" y2="48" stroke="black" stroke-width="3"/>
                <line x1="36" y1="40" x2="38" y2="48" stroke="black" stroke-width="3"/>
                <line x1="8" y1="30" x2="0" y2="27" stroke="black" stroke-width="3"/>
                <line x1="8" y1="31" x2="0" y2="31" stroke="black" stroke-width="3"/>
                <rect x="19" y="10" width="12" height="15" stroke="black" stroke-width="2" fill="#555"/>
            </svg>
        `);
        
        const autoHammerImg = new Image();
        autoHammerImg.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
            <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                <circle cx="25" cy="25" r="20" fill="#8B4513" stroke="#5D3A1A" stroke-width="2"/>
                <rect x="15" y="5" width="20" height="25" fill="#A0522D" rx="2"/>
                <rect x="22" y="5" width="6" height="35" fill="#8B4513"/>
                <circle cx="25" cy="25" r="5" fill="#5D3A1A"/>
                <path d="M25,20 L35,15 L35,35 L25,30 Z" fill="#A0522D"/>
            </svg>
        `);
        
        let laserTurrets = [];
        let forceFields = [];
        let explosions = [];
        
        let level = 1;
        let experience = 0;
        let experienceToNextLevel = 100;
        let achievements = {
            firstKill: false,
            turretMaster: false,
            barricadeKing: false,
            rich: false
        };
        
        let isPaused = false;
        let lastSpawnTime = 0;
        let spawnInterval = 1500;
        
        let powerUps = [];
        let powerUpTypes = {
            SPEED_BOOST: {
                color: '#FFC107',
                duration: 5000,
                effect: (game) => {
                    game.spawnInterval = 750;
                    setTimeout(() => {
                        game.spawnInterval = 1500;
                    }, 5000);
                }
            },
            MONEY_BOOST: {
                color: '#4CAF50',
                duration: 10000,
                effect: (game) => {
                    game.moneyMultiplier = 2;
                    setTimeout(() => {
                        game.moneyMultiplier = 1;
                    }, 10000);
                }
            },
            SCORE_BOOST: {
                color: '#2196F3',
                duration: 8000,
                effect: (game) => {
                    game.scoreMultiplier = 2;
                    setTimeout(() => {
                        game.scoreMultiplier = 1;
                    }, 8000);
                }
            }
        };
        
        let moneyMultiplier = 1;
        let scoreMultiplier = 1;
        
        const WATERMELON_TYPES = {
            NORMAL: {
                color: '#4CAF50',
                health: 2,
                speed: 1,
                points: 10,
                money: 10,
                particleColor: '#4CAF50'
            },
            ARMORED: {
                color: '#9E9E9E',
                health: 5,
                speed: 0.6,
                points: 20,
                money: 20,
                particleColor: '#9E9E9E'
            },
            FAST: {
                color: '#FFC107',
                health: 1,
                speed: 1.8,
                points: 15,
                money: 15,
                particleColor: '#FFC107'
            },
            STRONG: {
                color: '#F44336',
                health: 8,
                speed: 0.8,
                points: 30,
                money: 30,
                particleColor: '#F44336'
            },
            BOSS: {
                color: '#9C27B0',
                health: 20,
                speed: 0.4,
                points: 100,
                money: 100,
                size: 30,
                particleColor: '#9C27B0'
            },
            SPLITTER: {
                color: '#00BCD4',
                health: 3,
                speed: 1.2,
                points: 25,
                money: 25,
                particleColor: '#00BCD4',
                onDeath: (game, watermelon) => {
                    for (let i = 0; i < 2; i++) {
                        game.watermelons.push({
                            x: watermelon.x,
                            y: watermelon.y + (i * 20 - 10),
                            health: 1,
                            speed: watermelon.speed * 1.5,
                            type: WATERMELON_TYPES.NORMAL,
                            size: WATERMELON_SIZE * 0.7
                        });
                    }
                }
            }
        };
        
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const size = Math.random() * 4 + 2;
                
                specialEffects.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size,
                    color,
                    life: 1,
                    decay: 0.02
                });
            }
        }
        
        function init() {
            loadGame();
            
            document.getElementById('hammerUpgrade').addEventListener('click', () => {
                if (money >= 50) {
                    money -= 50;
                    hammerLevel++;
                    document.getElementById('hammerLevel').textContent = hammerLevel;
                    updateUI();
                }
            });
            
            document.getElementById('buyAutoHammer').addEventListener('click', () => {
                if (money >= 200) {
                    money -= 200;
                    autoHammerCount++;
                    document.getElementById('autohammerCount').textContent = autoHammerCount;
                    updateUI();
                }
            });
            
            document.getElementById('buyTurret').addEventListener('click', () => {
                if (money >= 300) {
                    money -= 300;
                    turretCount++;
                    document.getElementById('turretCount').textContent = turretCount;
                    updateUI();
                }
            });
            
            document.getElementById('buyBarricade').addEventListener('click', () => {
                if (money >= 150) {
                    money -= 150;
                    barricadeCount++;
                    document.getElementById('barricadeCount').textContent = barricadeCount;
                    updateUI();
                }
            });
            
            document.getElementById('repairPineapple').addEventListener('click', () => {
                if (money >= 100) {
                    money -= 100;
                    repairPineapple(20);
                    updateUI();
                }
            });
            
            document.querySelectorAll('.inventoryItem').forEach(item => {
                item.addEventListener('click', () => {
                    const type = item.getAttribute('data-type');
                    
                    if (selectedItem === type) {
                        selectedItem = null;
                        document.querySelectorAll('.inventoryItem').forEach(i => i.classList.remove('selected'));
                    } else {
                        selectedItem = type;
                        document.querySelectorAll('.inventoryItem').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                    }
                });
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                hammerPos.x = (e.clientX - rect.left) * scaleX;
                hammerPos.y = (e.clientY - rect.top) * scaleY;
            });
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;
                
                if (selectedItem === 'autohammer' && autoHammerCount > 0) {
                    if (isValidTurretPosition(clickX, clickY)) {
                        autoHammers.push({
                            x: clickX,
                            y: clickY,
                            lastFired: 0,
                            bullets: []
                        });
                        autoHammerCount--;
                        document.getElementById('autohammerCount').textContent = autoHammerCount;
                    }
                } else if (selectedItem === 'turret' && turretCount > 0) {
                    if (isValidTurretPosition(clickX, clickY)) {
                    turrets.push({
                        x: clickX,
                        y: clickY,
                        rotation: 0,
                        lastFired: 0,
                        bullets: []
                    });
                    turretCount--;
                    document.getElementById('turretCount').textContent = turretCount;
                    }
                } else if (selectedItem === 'barricade' && barricadeCount > 0) {
                    barricades.push({
                        x: clickX,
                        y: clickY,
                        health: 200
                    });
                    barricadeCount--;
                    document.getElementById('barricadeCount').textContent = barricadeCount;
                } else if (selectedItem === 'hammer' || !selectedItem) {
                    if (!hammerSwinging) {
                        hammerSwinging = true;
                        hammerRotation = -Math.PI / 4;
                        
                        watermelons.forEach((watermelon, index) => {
                            const dx = watermelon.x - hammerPos.x;
                            const dy = watermelon.y - hammerPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < WATERMELON_SIZE + 40) {
                                createParticles(watermelon.x, watermelon.y, watermelon.type.particleColor, 5);
                                
                                if (updateWatermelonHealth(watermelon, BASE_HAMMER_DAMAGE * hammerLevel)) {
                                    const reward = watermelon.type.money;
                                    const points = watermelon.type.points;
                                    
                                    chainReactionEffect(watermelon.x, watermelon.y);
                                    createExplosion(watermelon.x, watermelon.y, watermelon.type.color, watermelon.size * 2);
                                    
                                    money += reward * moneyMultiplier;
                                    score += points * scoreMultiplier;
                                    
                                    lastKillTime = Date.now();
                                    combo++;
                                    if (combo > 2) {
                                        comboMultiplier = 1 + (combo * 0.1);
                                    }
                                    
                                    addExperience(points / 5);
                                }
                            }
                        });
                    }
                }
                
                updateUI();
            });
            
            document.getElementById('resumeButton').addEventListener('click', togglePause);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                    togglePause();
                }
            });
            
            requestAnimationFrame(gameLoop);
            setInterval(spawnWatermelon, 1500);
            setInterval(saveGame, 30000);
            updateShopItems();
        }
        
        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseMenu').style.display = isPaused ? 'block' : 'none';
        }
        
        function addExperience(amount) {
            experience += amount;
            if (experience >= experienceToNextLevel) {
                level++;
                experience -= experienceToNextLevel;
                experienceToNextLevel = Math.floor(experienceToNextLevel * 1.5);
                
                updateUI();
                updateShopItems();
            }
        }
        
        function spawnWatermelon() {
            if (isPaused) return;
            
            const now = Date.now();
            if (now - lastSpawnTime < spawnInterval) return;
            lastSpawnTime = now;
            
            const y = Math.random() * (canvas.height - 100) + 50;
            let typeKey;
            
            if (level >= 5 && Math.random() < 0.05) {
                typeKey = 'BOSS';
            } else if (level >= 3 && Math.random() < 0.1) {
                typeKey = 'SPLITTER';
            } else {
                if (level < 3 && Math.random() < 0.7) {
                    typeKey = 'NORMAL';
                } else {
                    const typeKeys = Object.keys(WATERMELON_TYPES).filter(k => k !== 'BOSS' && k !== 'SPLITTER');
                    typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
                }
            }
            
            if (Math.random() < 0.08) {
                const powerUpKeys = Object.keys(powerUpTypes);
                const powerUpKey = powerUpKeys[Math.floor(Math.random() * powerUpKeys.length)];
                powerUps.push({
                    x: 0,
                    y: y,
                    type: powerUpTypes[powerUpKey],
                    size: 15
                });
            }
            
            const type = WATERMELON_TYPES[typeKey];
            
            const levelMultiplier = Math.min(1, 0.5 + (level * 0.1));
            const adjustedHealth = Math.ceil(type.health * levelMultiplier);
            
            watermelons.push({
                x: 0,
                y,
                health: adjustedHealth,
                speed: type.speed * (Math.random() * 0.2 + 0.9),
                type: type,
                size: type.size || WATERMELON_SIZE,
                particleColor: type.particleColor
            });
        }
        
        function updateUI() {
            moneyDisplay.textContent = money;
            scoreDisplay.textContent = score;
            
            document.getElementById('level').textContent = level;
            document.getElementById('levelProgress').style.width = 
                (experience / experienceToNextLevel * 100) + '%';
            
            if (score > 0 && !achievements.firstKill) {
                achievements.firstKill = true;
                document.getElementById('achFirstKill').classList.add('unlocked');
            }
            if (autoHammers.length >= 5 && !achievements.turretMaster) {
                achievements.turretMaster = true;
                document.getElementById('achTurretMaster').classList.add('unlocked');
            }
            if (barricades.length >= 5 && !achievements.barricadeKing) {
                achievements.barricadeKing = true;
                document.getElementById('achBarricadeKing').classList.add('unlocked');
            }
            if (money >= 1000 && !achievements.rich) {
                achievements.rich = true;
                document.getElementById('achRich').classList.add('unlocked');
            }
            
            updateShopItems();
        }
        
        function findTargetForTurret(turret, watermelons) {
            let bestTarget = null;
            let bestScore = -Infinity;
            
            watermelons.forEach(watermelon => {
                if (watermelon.x >= LINE_X) return;
                
                const dx = watermelon.x - turret.x;
                const dy = watermelon.y - turret.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 300) return;
                
                let score = 0;
                
                if (watermelon.type === WATERMELON_TYPES.BOSS) {
                    score += 100;
                } else if (watermelon.type === WATERMELON_TYPES.STRONG) {
                    score += 50;
                } else if (watermelon.type === WATERMELON_TYPES.ARMORED) {
                    score += 30;
                }
                
                const healthPercent = watermelon.health / watermelon.type.health;
                score += (1 - healthPercent) * 50;
                
                score -= dist * 0.1;
                
                const targetingCount = turrets.filter(t => {
                    if (t === turret) return false;
                    const tdx = t.x - watermelon.x;
                    const tdy = t.y - watermelon.y;
                    return Math.sqrt(tdx * tdx + tdy * tdy) < 300;
                }).length;
                
                score -= targetingCount * 20;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = watermelon;
                }
            });
            
            return bestTarget;
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                '0, 0, 0';
        }
        
        function createExplosion(x, y, color, size = 20) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const particleSize = Math.random() * 4 + 2;
                
                specialEffects.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize,
                    color,
                    life: 1,
                    decay: 0.02
                });
            }
            
            specialEffects.push({
                x,
                y,
                vx: 0,
                vy: 0,
                size: size,
                color: color,
                life: 1,
                decay: 0.05,
                isShockwave: true
            });
        }
        
        function drawBarricade(x, y, health) {
            ctx.save();
            ctx.translate(x, y);
            
            const gradient = ctx.createLinearGradient(-40, -30, 40, 30);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(1, '#A0522D');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(-40, -30, 80, 60);
            
            ctx.fillStyle = '#A0522D';
            ctx.beginPath();
            ctx.moveTo(-35, -30);
            ctx.lineTo(-25, -40);
            ctx.lineTo(45, -40);
            ctx.lineTo(35, -30);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(40, -30);
            ctx.lineTo(50, -40);
            ctx.lineTo(50, 20);
            ctx.lineTo(40, 30);
            ctx.fill();
            
            const healthPercent = health / 200;
            ctx.fillStyle = '#333';
            ctx.fillRect(-40, -40, 80, 5);
            
            const healthGradient = ctx.createLinearGradient(-40, -40, 40, -35);
            healthGradient.addColorStop(0, healthPercent > 0.5 ? '#4CAF50' : '#FF5722');
            healthGradient.addColorStop(1, healthPercent > 0.5 ? '#45a049' : '#f44336');
            
            ctx.fillStyle = healthGradient;
            ctx.fillRect(-40, -40, 80 * healthPercent, 5);
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = healthPercent > 0.5 ? '#4CAF50' : '#FF5722';
            ctx.fillRect(-40, -40, 80 * healthPercent, 5);
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        
        function drawWatermelon(x, y, type, size) {
            ctx.save();
            ctx.translate(x, y);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            gradient.addColorStop(0, type.color);
            gradient.addColorStop(1, shadeColor(type.color, -20));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = shadeColor(type.color, -30);
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI) / 5;
                ctx.beginPath();
                ctx.moveTo(
                    Math.cos(angle) * size,
                    Math.sin(angle) * size
                );
                ctx.lineTo(
                    Math.cos(angle + Math.PI) * size,
                    Math.sin(angle + Math.PI) * size
                );
                ctx.stroke();
            }
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = type.color;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return "#"+RR+GG+BB;
        }
        
        function drawPineapple(x, y, healthPercent) {
            ctx.save();
            ctx.translate(x, y);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
            gradient.addColorStop(0, '#FFEB3B');
            gradient.addColorStop(1, '#FFC107');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#FFA000';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(-15, -30);
            ctx.lineTo(0, -50);
            ctx.lineTo(15, -30);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.fillRect(-30, 40, 60, 8);
            
            const barGradient = ctx.createLinearGradient(-30, 40, 30, 48);
            barGradient.addColorStop(0, healthPercent > 0.5 ? '#4CAF50' : '#FF5722');
            barGradient.addColorStop(1, healthPercent > 0.5 ? '#45a049' : '#f44336');
            
            ctx.fillStyle = barGradient;
            ctx.fillRect(-30, 40, 60 * healthPercent, 8);
            
            ctx.restore();
        }
        
        function drawAutoHammer(x, y, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            const baseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            baseGradient.addColorStop(0, '#555');
            baseGradient.addColorStop(1, '#333');
            
            ctx.fillStyle = baseGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#666';
            ctx.fillRect(-5, -30, 10, 30);
            
            ctx.fillStyle = '#444';
            ctx.fillRect(-15, -40, 30, 20);
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#2196F3';
            ctx.fillRect(-15, -40, 30, 20);
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        
        function drawTurret(x, y, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.drawImage(turretImg, -25, -25, 50, 50);
            
            ctx.restore();
        }
        
        function gameLoop() {
            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.beginPath();
            ctx.moveTo(LINE_X, 0);
            ctx.lineTo(LINE_X, canvas.height);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 5;
            ctx.stroke();
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'red';
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            drawPineapple(pineapple.x, pineapple.y, pineapple.health / pineapple.maxHealth);
            
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(canvas.width, 10);
            ctx.moveTo(0, canvas.height - 10);
            ctx.lineTo(canvas.width, canvas.height - 10);
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'blue';
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            specialEffects = specialEffects.filter(effect => {
                effect.x += effect.vx;
                effect.y += effect.vy;
                effect.life -= effect.decay;
                
                if (effect.life <= 0) return false;
                
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${hexToRgb(effect.color)}, ${effect.life})`;
                ctx.fill();
                
                return true;
            });
            
            powerUps.forEach((powerUp, index) => {
                powerUp.x += 2;
                
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, powerUp.size, 0, Math.PI * 2);
                ctx.fillStyle = powerUp.type.color;
                ctx.fill();
                
                const dx = hammerPos.x - powerUp.x;
                const dy = hammerPos.y - powerUp.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < powerUp.size + 20) {
                    powerUp.type.effect(this);
                    powerUps.splice(index, 1);
                    createParticles(powerUp.x, powerUp.y, powerUp.type.color, 20);
                }
                
                if (powerUp.x > canvas.width) {
                    powerUps.splice(index, 1);
                }
            });
            
            const now = Date.now();
            if (now - lastKillTime > comboTimeout) {
                combo = 0;
                comboMultiplier = 1;
            }
            
            for (let i = watermelons.length - 1; i >= 0; i--) {
                const watermelon = watermelons[i];
                
                watermelon.x += watermelon.speed;
                
                if (checkWatermelonCollision(watermelon)) {
                    continue;
                }
                
                if (watermelon.x > LINE_X) {
                    pineapple.health -= watermelon.type.health / 2;
                    
                    watermelons.splice(i, 1);
                    
                    createExplosion(watermelon.x, watermelon.y, watermelon.type.color, watermelon.size * 2);
                    
                    if (pineapple.health <= 0) {
                        gameOver();
                    }
                    
                    continue;
                }
                
                drawWatermelon(watermelon.x, watermelon.y, watermelon.type, watermelon.size);
                
                const healthPercent = watermelon.health / watermelon.type.health;
                ctx.fillStyle = '#333';
                ctx.fillRect(watermelon.x - watermelon.size, watermelon.y - watermelon.size - 8, watermelon.size * 2, 4);
                
                const healthGradient = ctx.createLinearGradient(
                    watermelon.x - watermelon.size,
                    watermelon.y - watermelon.size - 8,
                    watermelon.x + watermelon.size,
                    watermelon.y - watermelon.size - 4
                );
                healthGradient.addColorStop(0, healthPercent > 0.5 ? '#4CAF50' : '#FF5722');
                healthGradient.addColorStop(1, healthPercent > 0.5 ? '#45a049' : '#f44336');
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(
                    watermelon.x - watermelon.size,
                    watermelon.y - watermelon.size - 8,
                    watermelon.size * 2 * healthPercent,
                    4
                );
                
                ctx.shadowBlur = 5;
                ctx.shadowColor = healthPercent > 0.5 ? '#4CAF50' : '#FF5722';
                ctx.fillRect(
                    watermelon.x - watermelon.size,
                    watermelon.y - watermelon.size - 8,
                    watermelon.size * 2 * healthPercent,
                    4
                );
                ctx.shadowBlur = 0;
            }
            
            autoHammers.forEach(autoHammer => {
                const target = findTargetForTurret(autoHammer, watermelons);
                let rotation = 0;
                
                if (target) {
                    const dx = target.x - autoHammer.x;
                    const dy = target.y - autoHammer.y;
                    rotation = Math.atan2(dy, dx) - Math.PI / 2;
                    
                    const now = Date.now();
                    if (now - autoHammer.lastFired > 2000) {
                        autoHammer.lastFired = now;
                        
                        target.health -= 2;
                        if (target.health <= 0) {
                            const index = watermelons.indexOf(target);
                            if (index > -1) {
                                watermelons.splice(index, 1);
                                money += target.type.money;
                                score += target.type.points;
                                updateUI();
                            }
                        }
                    }
                }
                
                drawAutoHammer(autoHammer.x, autoHammer.y, rotation);
            });
            
            turrets.forEach(turret => {
                const target = findTargetForTurret(turret, watermelons);
                
                if (target) {
                    const dx = target.x - turret.x;
                    const dy = target.y - turret.y;
                    turret.rotation = Math.atan2(dy, dx);
                    
                    const now = Date.now();
                    if (now - turret.lastFired > 1000) {
                        turret.lastFired = now;
                        
                        const bulletSpeed = 7;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const timeToHit = distance / bulletSpeed;
                        
                        const predictedX = target.x + target.speed * timeToHit;
                        const predictedY = target.y;
                        
                        turret.bullets.push({
                            x: turret.x,
                            y: turret.y,
                            targetX: predictedX,
                            targetY: predictedY,
                            speed: bulletSpeed,
                            tracer: [],
                            startTime: now
                        });
                    }
                }
                
                drawTurret(turret.x, turret.y, turret.rotation);
                
                for (let i = turret.bullets.length - 1; i >= 0; i--) {
                    const bullet = turret.bullets[i];
                    
                    bullet.tracer.push({x: bullet.x, y: bullet.y});
                    if (bullet.tracer.length > 5) {
                        bullet.tracer.shift();
                    }
                    
                    const dx = bullet.targetX - bullet.x;
                    const dy = bullet.targetY - bullet.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < bullet.speed) {
                        turret.bullets.splice(i, 1);
                        
                        let hitAny = false;
                        for (let j = watermelons.length - 1; j >= 0; j--) {
                            const watermelon = watermelons[j];
                            const hitDx = watermelon.x - bullet.x;
                            const hitDy = watermelon.y - bullet.y;
                            const hitDist = Math.sqrt(hitDx * hitDx + hitDy * hitDy);
                            
                            if (hitDist < WATERMELON_SIZE + 15) {
                                hitAny = true;
                                createParticles(watermelon.x, watermelon.y, watermelon.type.particleColor, 10);
                                
                                if (updateWatermelonHealth(watermelon, 3)) {
                                    const reward = watermelon.type.money;
                                    const points = watermelon.type.points;
                                    
                                    chainReactionEffect(watermelon.x, watermelon.y);
                                    
                                    money += reward;
                                    score += points;
                                    updateUI();
                                }
                                break;
                            }
                        }
                        
                        if (!hitAny) {
                            createParticles(bullet.x, bullet.y, '#999999', 5);
                        }
                    } else {
                        bullet.x += (dx / dist) * bullet.speed;
                        bullet.y += (dy / dist) * bullet.speed;
                        
                        if (bullet.tracer.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(bullet.tracer[0].x, bullet.tracer[0].y);
                            for (let t = 1; t < bullet.tracer.length; t++) {
                                ctx.lineTo(bullet.tracer[t].x, bullet.tracer[t].y);
                            }
                            ctx.lineTo(bullet.x, bullet.y);
                            ctx.strokeStyle = 'rgba(255, 165, 0, 0.6)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFA500';
                        ctx.fill();
                        
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            });
            
            barricades.forEach(barricade => {
                drawBarricade(barricade.x, barricade.y, barricade.health);
            });
            
            if (hammerSwinging) {
                hammerRotation += 0.2;
                if (hammerRotation > Math.PI / 2) {
                    hammerSwinging = false;
                    hammerRotation = 0;
                }
            }
            
            ctx.save();
            ctx.translate(hammerPos.x, hammerPos.y);
            ctx.rotate(hammerRotation);
            ctx.drawImage(hammerImg, -15, -50, 30, 70);
            ctx.restore();
            
            if (selectedItem) {
                ctx.globalAlpha = 0.5;
                if (selectedItem === 'turret' && turretCount > 0) {
                    ctx.drawImage(turretImg, hammerPos.x - 25, hammerPos.y - 25, 50, 50);
                } else if (selectedItem === 'barricade' && barricadeCount > 0) {
                    drawBarricade(hammerPos.x, hammerPos.y, 200);
                }
                ctx.globalAlpha = 1.0;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function gameOver() {
            isPaused = true;
            
            const gameOverDiv = document.createElement('div');
            gameOverDiv.id = 'gameOverMenu';
            gameOverDiv.style.position = 'absolute';
            gameOverDiv.style.top = '50%';
            gameOverDiv.style.left = '50%';
            gameOverDiv.style.transform = 'translate(-50%, -50%)';
            gameOverDiv.style.background = 'rgba(0, 0, 0, 0.8)';
            gameOverDiv.style.color = '#ecf0f1';
            gameOverDiv.style.padding = '20px';
            gameOverDiv.style.borderRadius = '8px';
            gameOverDiv.style.textAlign = 'center';
            gameOverDiv.style.zIndex = '100';
            gameOverDiv.style.backdropFilter = 'blur(5px)';
            gameOverDiv.style.border = '1px solid rgba(255, 255, 255, 0.1)';
            
            gameOverDiv.innerHTML = `
                <h2>Game Over</h2>
                <p>Your pineapple was destroyed!</p>
                <p>Final Score: ${score}</p>
                <button id="restartButton">Restart Game</button>
            `;
            
            document.getElementById('gameContainer').appendChild(gameOverDiv);
            
            document.getElementById('restartButton').addEventListener('click', () => {
                gameOverDiv.remove();
                restartGame();
            });
        }
        
        function repairPineapple(amount) {
            pineapple.health = Math.min(pineapple.maxHealth, pineapple.health + amount);
        }
        
        function saveGame() {
            gameState.money = money;
            gameState.score = score;
            gameState.hammerLevel = hammerLevel;
            gameState.level = level;
            gameState.autoHammerCount = autoHammerCount;
            gameState.turretCount = turretCount;
            gameState.barricadeCount = barricadeCount;
            gameState.experience = experience;
            gameState.experienceToNextLevel = experienceToNextLevel;
            gameState.achievements = achievements;
            gameState.pineappleHealth = pineapple.health;
            
            const gameStateJSON = JSON.stringify(gameState);
            const expiryDate = new Date();
            expiryDate.setTime(expiryDate.getTime() + (30 * 24 * 60 * 60 * 1000));
            document.cookie = `watermelonGameState=${encodeURIComponent(gameStateJSON)};expires=${expiryDate.toUTCString()};path=/`;
        }
        
        function loadGame() {
            const cookies = document.cookie.split(';');
            let gameStateCookie = null;
            
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.indexOf('watermelonGameState=') === 0) {
                    gameStateCookie = cookie.substring('watermelonGameState='.length, cookie.length);
                    break;
                }
            }
            
            if (gameStateCookie) {
                try {
                    const savedState = JSON.parse(decodeURIComponent(gameStateCookie));
                    
                    money = savedState.money || 0;
                    score = savedState.score || 0;
                    hammerLevel = savedState.hammerLevel || 1;
                    level = savedState.level || 1;
                    autoHammerCount = savedState.autoHammerCount || 0;
                    turretCount = savedState.turretCount || 0;
                    barricadeCount = savedState.barricadeCount || 0;
                    experience = savedState.experience || 0;
                    experienceToNextLevel = savedState.experienceToNextLevel || 100;
                    achievements = savedState.achievements || {
                        firstKill: false,
                        turretMaster: false,
                        barricadeKing: false,
                        rich: false
                    };
                    
                    if (savedState.pineappleHealth) {
                        pineapple.health = savedState.pineappleHealth;
                    }
                    
                    document.getElementById('hammerLevel').textContent = hammerLevel;
                    document.getElementById('autohammerCount').textContent = autoHammerCount;
                    document.getElementById('turretCount').textContent = turretCount;
                    document.getElementById('barricadeCount').textContent = barricadeCount;
                    updateUI();
                } catch (error) {
                    console.error('Error loading saved game:', error);
                }
            }
        }
        
        function restartGame() {
            money = 0;
            score = 0;
            watermelons = [];
            autoHammers = [];
            turrets = [];
            barricades = [];
            hammerLevel = 1;
            autoHammerCount = 0;
            turretCount = 0;
            barricadeCount = 0;
            combo = 0;
            comboMultiplier = 1;
            lastKillTime = 0;
            specialEffects = [];
            pineapple.health = pineapple.maxHealth;
            level = 1;
            experience = 0;
            experienceToNextLevel = 100;
            
            document.getElementById('hammerLevel').textContent = hammerLevel;
            document.getElementById('autohammerCount').textContent = autoHammerCount;
            document.getElementById('turretCount').textContent = turretCount;
            document.getElementById('barricadeCount').textContent = barricadeCount;
            updateUI();
            
            isPaused = false;
        }
        
        function checkWatermelonCollision(watermelon) {
            for (let i = barricades.length - 1; i >= 0; i--) {
                const barricade = barricades[i];
                const dx = watermelon.x - barricade.x;
                const dy = watermelon.y - barricade.y;
                
                if (Math.abs(dx) < 40 && Math.abs(dy) < 30) {
                    barricade.health -= 1;
                    
                    watermelon.x = barricade.x - 40;
                    
                    if (barricade.health <= 0) {
                        barricades.splice(i, 1);
                    }
                    
                    return true;
                }
            }
            
            for (let i = forceFields.length - 1; i >= 0; i--) {
                const field = forceFields[i];
                const dx = watermelon.x - field.x;
                const dy = watermelon.y - field.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < field.radius + watermelon.size) {
                    field.health -= 1;
                    watermelon.health -= 1;
                    
                    if (field.health <= 0) {
                        forceFields.splice(i, 1);
                    }
                    
                    return true;
                }
            }
            
            return false;
        }
        
        function isValidTurretPosition(x, y) {
            if (x < 50 || x > canvas.width - 50 || y < 50 || y > canvas.height - 50) {
                return false;
            }
            
            for (const turret of turrets) {
                const dx = x - turret.x;
                const dy = y - turret.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 100) {
                    return false;
                }
            }
            
            for (const barricade of barricades) {
                const dx = x - barricade.x;
                const dy = y - barricade.y;
                if (Math.abs(dx) < 60 && Math.abs(dy) < 50) {
                    return false;
                }
            }
            
            return true;
        }
        
        function updateWatermelonHealth(watermelon, damage) {
            watermelon.health = Math.max(0, watermelon.health - damage);
            
            if (watermelon.health <= 0) {
                const index = watermelons.indexOf(watermelon);
                if (index > -1) {
                    watermelons.splice(index, 1);
                    return true;
                }
            }
            return false;
        }
        
        function updateShopItems() {
            document.getElementById('hammerUpgrade').disabled = money < 50;
            document.getElementById('buyAutoHammer').disabled = money < 200;
            document.getElementById('buyTurret').disabled = money < 300;
            document.getElementById('buyBarricade').disabled = money < 150;
            document.getElementById('repairPineapple').disabled = money < 100 || pineapple.health >= pineapple.maxHealth;
        }
        
        function chainReactionEffect(sourceX, sourceY) {
            for (let i = watermelons.length - 1; i >= 0; i--) {
                const watermelon = watermelons[i];
                const dx = watermelon.x - sourceX;
                const dy = watermelon.y - sourceY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0 && distance < SPLASH_RADIUS) {
                    const damageFactor = 1 - (distance / SPLASH_RADIUS);
                    const damage = Math.ceil(BASE_HAMMER_DAMAGE * hammerLevel * damageFactor);
                    
                    createConnectingParticles(sourceX, sourceY, watermelon.x, watermelon.y, watermelon.type.particleColor);
                    
                    if (updateWatermelonHealth(watermelon, damage)) {
                        const reward = watermelon.type.money;
                        const points = watermelon.type.points;
                        
                        createExplosion(watermelon.x, watermelon.y, watermelon.type.color, watermelon.size * 1.5);
                        
                        money += reward * moneyMultiplier;
                        score += points * scoreMultiplier;
                        
                        addExperience(points / 10);
                    }
                }
            }
        }
        
        function createConnectingParticles(x1, y1, x2, y2, color) {
            const distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            const count = Math.floor(distance / 10);
            
            for (let i = 0; i < count; i++) {
                const ratio = i / count;
                const x = x1 + (x2 - x1) * ratio;
                const y = y1 + (y2 - y1) * ratio;
                
                specialEffects.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 4 + 2,
                    color,
                    life: 1,
                    decay: 0.05
                });
            }
        }
        
        window.onload = init;
    </script>
</body>
</html>
